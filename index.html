<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Vehicle Controller (Futuristic UI)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&family=Montserrat:wght=300..700&display=swap" rel="stylesheet">
    <style>
        /* グローバルスタイル */
        body {
            font-family: 'Montserrat', sans-serif; /* メインフォント */
            background-color: #0c0f16; /* ディープダークブルー */
            color: #e0e6f0; /* 明るいオフホワイト */
            display: flex;
            justify-content: center;
            align-items: center; /* 垂直中央揃え */
            min-height: 100vh;
            padding: 1rem;
            overflow-x: hidden; /* 横スクロール禁止 */
        }
        .container {
            width: 100%;
            max-width: 520px; /* 少し広げる */
            background-color: #1a1e26; /* 暗めの背景 */
            border-radius: 1.5rem; /* 角丸を大きく */
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.15), 0 0 5px rgba(0, 255, 255, 0.2); /* サイバーな光沢 */
            border: 1px solid rgba(0, 255, 255, 0.3); /* 細い枠線 */
            overflow: hidden;
        }

        /* ヘッダー */
        .header {
            background-image: linear-gradient(to right, #00c6ff, #0072ff); /* グラデーション */
            color: white;
            padding: 1.5rem;
            text-align: center;
            border-bottom: 2px solid rgba(0, 255, 255, 0.5);
            position: relative;
        }
        .header h1 {
            font-family: 'Orbitron', sans-serif; /* 近未来的タイトルフォント */
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: 0.05em; /* 文字間隔 */
            text-shadow: 0 0 10px rgba(255,255,255,0.7);
        }
        .header p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 0.3rem;
        }
        .header::after { /* 下部の光のライン */
            content: '';
            position: absolute;
            bottom: 0;
            left: 5%;
            width: 90%;
            height: 2px;
            background: linear-gradient(to right, transparent, #00ffff, transparent);
            box-shadow: 0 0 8px #00ffff;
        }

        /* ステータスボックス */
        .status-box {
            padding: 0.8rem 1rem;
            margin-top: 0.6rem;
            border-radius: 0.75rem; /* 角丸を大きめに */
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            border: 1px solid transparent; /* デフォルトの枠線 */
            transition: all 0.3s ease;
        }
        .status-icon {
            margin-right: 0.75rem;
            font-size: 1.2em;
        }
        .status-driving { 
            background-color: #0f3d37; 
            color: #66ffcc; 
            border-color: #00ff99; 
            box-shadow: 0 0 8px rgba(0, 255, 153, 0.4);
        }
        .status-pause { 
            background-color: #4a3e0f; 
            color: #ffe066; 
            border-color: #ffcc00;
            box-shadow: 0 0 8px rgba(255, 204, 0, 0.4);
        }
        .status-wait { 
            background-color: #1a2e4f; 
            color: #99ccff; 
            border-color: #3399ff;
            box-shadow: 0 0 8px rgba(51, 153, 255, 0.4);
        }
        .status-complete { 
            background-color: #3a1a4a; 
            color: #cc99ff; 
            border-color: #9933ff;
            box-shadow: 0 0 8px rgba(153, 51, 255, 0.4);
        }
        .status-neutral { /* AI Decision, Command Log用 */
            background-color: #23272f;
            color: #a0a8b4;
            border-color: #3f475a;
        }
        .command-log-item {
            display: block;
            margin-bottom: 0.25rem;
        }
        .log-error { color: #ff6b6b; }
        .log-success { color: #66ffcc; }
        .log-info { color: #99ccff; }

        /* カメラとAIオーバーレイ */
        /* 1. 映像部分のはみ出し修正：外側のパディングを削除 */
        .camera-container {
            position: relative;
            width: calc(100% - 2.5rem); /* コンテナのパディング1.25rem * 2 を引く */
            margin: 1.25rem auto 0 auto; /* 中央寄せと上部マージン */
            padding-top: 75%; 
            overflow: hidden;
            background-color: #000;
            border-radius: 1rem; 
            border: 2px solid #00c6ff; 
            box-shadow: 0 0 15px rgba(0, 198, 255, 0.6);
        }
        #viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            border-radius: 1rem;
        }
        #cameraFeed, #aiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 1.0s ease-out;
        }
        #aiCanvas {
            pointer-events: none;
        }
        #aiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column; 
            justify-content: space-between; 
            padding: 1.25rem; 
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #aiDecisionText {
            font-family: 'Orbitron', sans-serif; 
            font-size: 1.2rem;
            font-weight: bold;
            color: #00ffff; 
            background-color: rgba(0, 0, 0, 0.7);
            padding: 0.6rem 1rem;
            border-radius: 0.75rem;
            align-self: center; /* 中央下部に配置 */
            margin-top: auto; 
            border: 1px solid rgba(0, 255, 255, 0.5);
        }

        /* ボタン */
        .control-button {
            background-image: linear-gradient(to right, #007bff, #00c6ff);
            color: white;
            font-weight: bold;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 198, 255, 0.4);
            border: none;
        }
        .control-button:hover {
            background-image: linear-gradient(to right, #00c6ff, #007bff);
            box-shadow: 0 6px 20px rgba(0, 198, 255, 0.6);
            transform: translateY(-2px);
        }
        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 198, 255, 0.4);
        }
        .control-button:disabled {
            background-image: none;
            background-color: #3f475a;
            color: #a0a8b4;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* 起動ボタン */
        #startCameraButton {
            background-image: linear-gradient(to right, #33cc33, #00cc66);
            box-shadow: 0 4px 15px rgba(51, 204, 51, 0.4);
        }
        #startCameraButton:hover {
            background-image: linear-gradient(to right, #00cc66, #33cc33);
            box-shadow: 0 6px 20px rgba(51, 204, 51, 0.6);
        }
    </style>
</head>
<body>

<div class="container rounded-3xl shadow-2xl">
    <div class="header">
        <h1 class="text-2xl">AI Vehicle Controller</h1>
        <p class="text-sm">次世代自律走行システムデモンストレーション</p>
    </div>

    <!-- カメラフィードとAIオーバーレイ -->
    <div class="camera-container">
        <div id="viewport">
            <video id="cameraFeed" autoplay playsinline></video>
            <canvas id="aiCanvas"></canvas> 
        </div>
        <div id="aiOverlay">
            <span id="aiDecisionText">カメラを起動してください</span>
        </div>
    </div>

    <!-- 制御ステータス -->
    <div class="p-5 border-t border-gray-700 mt-4">
        <h2 class="text-lg font-semibold mb-3 text-cyan-400">システムステータス</h2>
        
        <div class="flex flex-col space-y-3">
            <div id="arduinoStatus" class="status-box status-wait">
                <span class="status-icon">●</span> Arduino State: WAIT_START (待機中)
            </div>
            
            <div id="decisionOutput" class="status-box status-neutral">
                <span class="status-icon">⚡</span> AI Decision: 監視中
            </div>

            <div id="commandLog" class="status-box status-neutral text-sm h-20 overflow-y-auto">
                <span class="status-icon">▶</span> Command Log: -
            </div>
        </div>
    </div>

    <!-- マニュアル操作ボタン（デバッグ用） -->
    <div class="p-5 border-t border-gray-700">
        <h2 class="text-lg font-semibold mb-3 text-cyan-400">手動制御 (Bluetooth送信シミュレーション)</h2>
        <div class="grid grid-cols-3 gap-3">
            <button onclick="sendManualCommand('TURN_L')" class="control-button">左旋回</button>
            <button onclick="sendManualCommand('FORWARD')" class="control-button">直進</button>
            <button onclick="sendManualCommand('TURN_R')" class="control-button">右旋回</button>
        </div>
        <button id="startCameraButton" class="mt-4 w-full control-button">カメラ/システム起動</button>
    </div>
</div>

<script>
    // ******************************************************
    // I. グローバル設定と状態変数
    // ******************************************************
    let arduinoState = 'WAIT_START'; 
    let isAiActive = false; 
    let aiLoopInterval = null;
    const UPDATE_INTERVAL_MS = 1000; // AI推論間隔（1秒）
    const CAMERA_WIDTH = 640;
    const CAMERA_HEIGHT = 480;

    let aiCanvas = null;
    let aiCtx = null;
    let videoElement = null;
    let isProcessing = false;
    let tempCanvas = null;

    // ******************************************************
    // II. Bluetooth通信のエミュレーション (変更なし)
    // ******************************************************
    class BluetoothEmulator {
        constructor() {
            this.apiUrl = "https://your-arduino-bluetooth-endpoint.com/command"; 
            this.isConnected = false;
        }
        async connect() {
            this.isConnected = true;
            this.log('Bluetooth: 接続成功。Arduinoからのステータス待機中。', 'info');
        }
        async sendCommand(command) {
            if (!this.isConnected) {
                this.log(`Bluetooth: 未接続のためコマンド[${command}]を送信できません。`, 'error');
                return;
            }
            this.log(`TX: ${command}`, 'success');
        }
        log(message, type = 'info') {
            const logElement = document.getElementById('commandLog');
            let colorClass = 'log-info';
            if (type === 'error') colorClass = 'log-error';
            if (type === 'success') colorClass = 'log-success';

            const now = new Date();
            const timeString = now.toLocaleTimeString();

            logElement.innerHTML = `<span class="${colorClass} command-log-item">[${timeString}] ${message}</span>` + logElement.innerHTML;
            logElement.scrollTop = 0; // 最新メッセージを常に表示
        }
    }
    const btEmulator = new BluetoothEmulator();

    // ******************************************************
    // III. AI判断ロジック (Gemini API シミュレーション)
    // ******************************************************
    function captureFrameAsBase64() {
        if (!tempCanvas) { tempCanvas = document.createElement('canvas'); }
        tempCanvas.width = videoElement.videoWidth;
        tempCanvas.height = videoElement.videoHeight;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);
        return tempCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];
    }

    async function analyzeFrame(base64Image) {
        const decisionTextElement = document.getElementById('aiDecisionText');
        await new Promise(resolve => setTimeout(resolve, 500)); 
        
        const obstacleChance = Math.floor(Math.random() * 100);
        let command = 'FORWARD';
        const detections = [];
        let primaryDetection = null;

        if (obstacleChance < 60) {
            let x_center, decision;

            if (obstacleChance < 20) { 
                x_center = 0.20; // 左端
                command = 'TURN_R';
                decision = "⚠ ターゲット（左）: 右へ回避＆追尾中";
            } else if (obstacleChance < 40) {
                x_center = 0.80; // 右端
                command = 'TURN_L';
                decision = "⚠ ターゲット（右）: 左へ回避＆追尾中";
            } else { 
                x_center = 0.50; // 中央
                command = 'FORWARD'; 
                decision = "⚠ ターゲット（中央）: 直進継続＆追尾中";
            }
            
            primaryDetection = { 
                x: x_center, 
                y: 0.7, 
                w: 0.2, 
                h: 0.3, 
                label: 'Tracking Target' 
            };
            detections.push(primaryDetection);
            decisionTextElement.textContent = decision;
            document.getElementById('decisionOutput').style.color = '#FF4136'; // 赤色
            
        } else {
            command = 'FORWARD';
            decisionTextElement.textContent = "✅ 安全走行: 自動追尾停止";
            document.getElementById('decisionOutput').style.color = '#66ffcc'; // 緑色
        }
        
        return { command, detections, primaryDetection };
    }

    // ******************************************************
    // IV. 描画と追尾シミュレーション
    // ******************************************************

    function drawDetections(detections) {
        if (!aiCtx || !aiCanvas) return;

        aiCtx.clearRect(0, 0, aiCanvas.width, aiCanvas.height);
        
        const cw = aiCanvas.width;
        const ch = aiCanvas.height;

        detections.forEach(det => {
            const x = det.x * cw - (det.w * cw / 2);
            const y = det.y * ch - (det.h * ch / 2);
            const w = det.w * cw;
            const h = det.h * ch;

            aiCtx.strokeStyle = '#00ffff'; /* シアン */
            aiCtx.lineWidth = 3;
            aiCtx.strokeRect(x, y, w, h);

            aiCtx.fillStyle = '#00ffff'; /* シアン */
            aiCtx.font = 'bold 16px Montserrat'; /* モダンフォント */
            aiCtx.fillText(det.label, x + 5, y + 20);
        });
    }

    function updateCameraTracking(targetDetection) {
        const elements = [videoElement, aiCanvas];

        if (!targetDetection) {
            elements.forEach(el => {
                el.style.transform = `scale(1.0) translate(0, 0)`;
            });
            return;
        }

        const TARGET_SCALE = 1.3; 
        const targetX = targetDetection.x;
        const targetY = targetDetection.y;

        const dx = 0.5 - targetX;
        const dy = 0.5 - targetY;
        
        const translateX = dx * 100 * TARGET_SCALE;
        const translateY = dy * 100 * TARGET_SCALE;

        elements.forEach(el => {
            el.style.transform = `scale(${TARGET_SCALE}) translate(${translateX}%, ${translateY}%)`;
        });
        
        btEmulator.log(`DPTZ: 追尾 (${targetDetection.label}) -> 移動 X:${translateX.toFixed(1)}% Y:${translateY.toFixed(1)}%`, 'info');
    }

    // ******************************************************
    // V. メイン制御ループ
    // ******************************************************

    async function aiControlLoop() {
        if (arduinoState !== 'DRIVING' || isProcessing) {
             if (arduinoState !== 'DRIVING') {
                 if (aiCtx && aiCanvas) { aiCtx.clearRect(0, 0, aiCanvas.width, aiCanvas.height); }
                 updateCameraTracking(null);
             }
             return;
        }

        isProcessing = true; 
        
        try {
            const base64Image = captureFrameAsBase64();
            const { command, detections, primaryDetection } = await analyzeFrame(base64Image); 
            
            btEmulator.sendCommand(command);
            
            document.getElementById('decisionOutput').textContent = `AI Decision: ${command}`;

            drawDetections(detections);
            updateCameraTracking(primaryDetection);

        } catch (error) {
            btEmulator.log(`AI Processing Error: ${error.message}`, 'error');
        } finally {
            isProcessing = false; 
        }
    }

    // ******************************************************
    // VI. カメラ初期化とイベントリスナー (AF強制ロジックを維持)
    // ******************************************************
    
    let isCameraInitialized = false;

    function adjustCanvasSize() {
        const viewport = document.getElementById('viewport');
        aiCanvas.width = viewport.clientWidth;
        aiCanvas.height = viewport.clientHeight;
        window.addEventListener('resize', () => {
             aiCanvas.width = viewport.clientWidth;
             aiCanvas.height = viewport.clientHeight;
        });
    }

    async function startCamera() {
        if (isCameraInitialized) return;

        videoElement = document.getElementById('cameraFeed');
        aiCanvas = document.getElementById('aiCanvas');
        aiCtx = aiCanvas.getContext('2d');
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: CAMERA_WIDTH, height: CAMERA_HEIGHT, facingMode: 'environment' } 
            });
            videoElement.srcObject = stream;
            
            videoElement.onloadedmetadata = async () => {
                adjustCanvasSize();

                const tracks = stream.getVideoTracks();
                if (tracks.length > 0) {
                    const track = tracks[0];
                    let afSuccess = false;

                    // 左右反転修正
                    const settings = track.getSettings();
                    if (settings.facingMode === 'user' || settings.facingMode === 'left') {
                         videoElement.style.transform = 'scaleX(-1)'; 
                    } else {
                         videoElement.style.transform = 'scaleX(1)';
                    }
                    
                    // 連続オートフォーカスを要求
                    try {
                        const capabilities = track.getCapabilities();
                        if (capabilities.focusMode && capabilities.focusMode.includes('continuous')) {
                            await track.applyConstraints({
                                advanced: [{ focusMode: 'continuous' }]
                            });
                            afSuccess = true;
                        } 
                    } catch (e) {
                         // AF設定に失敗しても続行（AF非対応のPCプレビューはこちらを通る）
                         btEmulator.log(`Camera: AF設定試行エラー: ${e.message}`, 'error');
                    }

                    // AF成功/非対応のメッセージをログに出力
                    if (afSuccess) {
                        btEmulator.log('Camera: 連続オートフォーカスを有効化しました。', 'info');
                    } else {
                        // 2. AF非対応メッセージの抑制：UIに出さずログにだけ記録
                        btEmulator.log('Camera: 連続AFは非対応または設定失敗。スマートフォンで動作を確認してください。', 'info');
                    }
                }

                btEmulator.connect(); 
                aiLoopInterval = setInterval(aiControlLoop, UPDATE_INTERVAL_MS);
                isCameraInitialized = true;
                document.getElementById('aiDecisionText').textContent = "AI監視中...";
                document.getElementById('startCameraButton').textContent = "システム稼働中";
                document.getElementById('startCameraButton').disabled = true;

            };
        } catch (err) {
            document.getElementById('aiDecisionText').textContent = "⚠ カメラ起動エラー: HTTPS環境と権限が必要です";
            btEmulator.log(`Camera Error: ${err.message}`, 'error');
        }
    }

    function sendManualCommand(command) {
        if (arduinoState === 'DRIVING') {
            btEmulator.sendCommand(command);
            document.getElementById('decisionOutput').textContent = `Manual Override: ${command}`;
        } else {
            btEmulator.log(`ERROR: ${arduinoState}状態ではマニュアルコマンドは送信できません。`, 'error');
        }
    }
    
    document.getElementById('startCameraButton').addEventListener('click', startCamera);

    // ******************************************************
    // VII. 発表デモ用：Arduinoステータス変化の模擬 (変更なし)
    // ******************************************************

    window.simulateArduinoPieceAction = function(action) {
        switch (action) {
            case 'place_piece':
                if (arduinoState === 'WAIT_START') {
                    receiveStatus('DRIVING_START');
                } else if (arduinoState === 'PAUSE') {
                    receiveStatus('DRIVING_RESUMED');
                }
                break;
            case 'remove_piece':
                if (arduinoState === 'DRIVING') {
                    receiveStatus('PAUSE_TRIPPED');
                } else if (arduinoState === 'COMPLETE') {
                    receiveStatus('SEQUENCE_RESET');
                }
                break;
            case 'complete_sequence':
                 if (arduinoState === 'DRIVING') {
                     receiveStatus('SEQUENCE_COMPLETE');
                 }
                 break;
        }
        btEmulator.log(`SIMULATED: Arduino Status Change: ${arduinoState}`, 'info');
    };
    
    setTimeout(() => {
        btEmulator.log("デモ準備完了: ピースを置く操作をシミュレートしてください (DRIVING_START)", 'info');
    }, 500);
    
    function receiveStatus(status) {
        let stateText;
        let stateClass;
        
        switch (status) {
            case 'DRIVING_START':
            case 'DRIVING_RESUMED':
                arduinoState = 'DRIVING';
                stateText = 'DRIVING (AI制御アクティブ)';
                stateClass = 'status-driving';
                break;
            case 'PAUSE_TRIPPED':
                arduinoState = 'PAUSE';
                stateText = 'PAUSE (ピース除去により一時停止)';
                stateClass = 'status-pause';
                break;
            case 'SEQUENCE_COMPLETE':
                arduinoState = 'COMPLETE';
                stateText = 'COMPLETE (課題完了)';
                stateClass = 'status-complete';
                break;
            default:
                arduinoState = 'WAIT_START';
                stateText = 'WAIT_START (待機中)';
                stateClass = 'status-wait';
                btEmulator.log(`ERROR: Unknown status received or reset to WAIT_START: ${status}`, 'error');
                break;
        }

        document.getElementById('arduinoStatus').textContent = `Arduino State: ${stateText}`;
        
        const statusElement = document.getElementById('arduinoStatus');
        statusElement.className = `status-box ${stateClass}`; 
    }

</script>
</body>
</html>
